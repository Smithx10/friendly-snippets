{
  "allow": {
    "prefix": "_allow",
    "body": [
      "#![allow(${1})]"
    ],
    "description": "#![allow(…)]"
  },
  "deny": {
    "prefix": "_deny",
    "body": [
      "#![deny(${1})]"
    ],
    "description": "#![deny(…)]"
  },
  "warn": {
    "prefix": "_warn",
    "body": [
      "#![warn(${1})]"
    ],
    "description": "#![warn(…)]"
  },
  "no_std": {
    "prefix": "_no_std",
    "body": [
      "#![no_std]"
    ],
    "description": "#![no_std]"
  },
  "no_core": {
    "prefix": "_no_core",
    "body": [
      "#![no_core]"
    ],
    "description": "#![no_core]"
  },
  "feature": {
    "prefix": "_feature",
    "body": [
      "#![feature(${1})]"
    ],
    "description": "#![feature(…)]"
  },
  "macro_use": {
    "prefix": "_macro_use",
    "body": [
      "#[macro_use(${1})]"
    ],
    "description": "#[macro_use(…)]"
  },
  "repr": {
    "prefix": "_repr",
    "body": [
      "#[repr(${1})]"
    ],
    "description": "#[repr(…)]"
  },
  "cfg": {
    "prefix": "_cfg",
    "body": [
      "#[cfg(${1})]"
    ],
    "description": "#[cfg(…)]"
  },
  "cfg_attr": {
    "prefix": "_cfg_attr",
    "body": [
      "#[cfg_attr(${1}, ${2})]"
    ],
    "description": "#[cfg_attr(…, …)]"
  },
  "cfg!": {
    "prefix": "_cfg!",
    "body": [
      "cfg!(${1})"
    ],
    "description": "cfg!(…)"
  },
  "column": {
    "prefix": "_column",
    "body": [
      "column!()"
    ],
    "description": "column!()"
  },
  "concat": {
    "prefix": "_concat",
    "body": [
      "concat!(${1})"
    ],
    "description": "concat!(…)"
  },
  "concat_idents": {
    "prefix": "_concat_idents",
    "body": [
      "concat_idents!(${1})"
    ],
    "description": "concat_idents!(…)"
  },
  "debug_assert": {
    "prefix": "_debug_assert",
    "body": [
      "debug_assert!(${1});"
    ],
    "description": "debug_assert!(…)"
  },
  "debug_assert_eq": {
    "prefix": "_debug_assert_eq",
    "body": [
      "debug_assert_eq!(${1}, ${2});"
    ],
    "description": "debug_assert_eq!(…, …)"
  },
  "env": {
    "prefix": "_env",
    "body": [
      "env!(\"${1}\")"
    ],
    "description": "env!(\"…\")"
  },
  "file": {
    "prefix": "_file",
    "body": [
      "file!()"
    ],
    "description": "file!()"
  },
  "format": {
    "prefix": "_format",
    "body": [
      "format!(\"${1}\")"
    ],
    "description": "format!(…)"
  },
  "format_args": {
    "prefix": "_format_args",
    "body": [
      "format_args!(\"${1}\")"
    ],
    "description": "format_args!(…)"
  },
  "include": {
    "prefix": "_include",
    "body": [
      "include!(\"${1}\");"
    ],
    "description": "include!(\"…\");"
  },
  "include_bytes": {
    "prefix": "_include_bytes",
    "body": [
      "include_bytes!(\"${1}\")"
    ],
    "description": "include_bytes!(\"…\")"
  },
  "include_str": {
    "prefix": "_include_str",
    "body": [
      "include_str!(\"${1}\")"
    ],
    "description": "include_str!(\"…\")"
  },
  "line": {
    "prefix": "_line",
    "body": [
      "line!()"
    ],
    "description": "line!()"
  },
  "module_path": {
    "prefix": "_module_path",
    "body": [
      "module_path!()"
    ],
    "description": "module_path!()"
  },
  "option_env": {
    "prefix": "_option_env",
    "body": [
      "option_env!(\"${1}\")"
    ],
    "description": "option_env!(\"…\")"
  },
  "panic": {
    "prefix": "_panic",
    "body": [
      "panic!(\"${1}\");"
    ],
    "description": "panic!(…);"
  },
  "print": {
    "prefix": "_print",
    "body": [
      "print!(\"${1}\");"
    ],
    "description": "print!(…);"
  },
  "println": {
    "prefix": "_println",
    "body": [
      "println!(\"${1}\");"
    ],
    "description": "println!(…);"
  },
  "stringify": {
    "prefix": "_stringify",
    "body": [
      "stringify!(${1})"
    ],
    "description": "stringify!(…)"
  },
  "thread_local": {
    "prefix": "_thread_local",
    "body": [
      "thread_local!(static ${1:STATIC}: ${2:Type} = ${4:init});"
    ],
    "description": "thread_local!(static …: … = …);"
  },
  "try": {
    "prefix": "_try",
    "body": [
      "try!(${1})"
    ],
    "description": "try!(…)"
  },
  "unimplemented": {
    "prefix": "_unimplemented",
    "body": [
      "unimplemented!()"
    ],
    "description": "unimplemented!()"
  },
  "unreachable": {
    "prefix": "_unreachable",
    "body": [
      "unreachable!(${1})"
    ],
    "description": "unreachable!(…)"
  },
  "vec": {
    "prefix": "_vec",
    "body": [
      "vec![${1}]"
    ],
    "description": "vec![…]"
  },
  "write": {
    "prefix": "_write",
    "body": [
      "write!(${1}, \"${2}\")"
    ],
    "description": "write!(…)"
  },
  "writeln": {
    "prefix": "_writeln",
    "body": [
      "writeln!(${1}, \"${2}\")"
    ],
    "description": "writeln!(…, …)"
  },
  "assert": {
    "prefix": "_assert",
    "body": [
      "assert!(${1});"
    ],
    "description": "assert!(…);"
  },
  "assert_eq": {
    "prefix": "_assert_eq",
    "body": [
      "assert_eq!(${1}, ${2});"
    ],
    "description": "assert_eq!(…, …);"
  },
  "bench": {
    "prefix": "_bench",
    "body": [
      "#[bench]",
      "fn ${1:name}(b: &mut test::Bencher) {",
      "    ${2:b.iter(|| ${3:/* benchmark code */})}",
      "}"
    ],
    "description": "#[bench]"
  },
  "const": {
    "prefix": "_const",
    "body": [
      "const ${1:CONST}: ${2:Type} = ${4:init};"
    ],
    "description": "const …: … = …;"
  },
  "derive": {
    "prefix": "_derive",
    "body": [
      "#[derive(${1})]"
    ],
    "description": "#[derive(…)]"
  },
  "enum": {
    "prefix": "_enum",
    "body": [
      "#[derive(Debug)]",
      "enum ${1:Name} {",
      "    ${2:Variant1},",
      "    ${3:Variant2},",
      "}"
    ],
    "description": "enum … { … }"
  },
  "extern-crate": {
    "prefix": "_extern-crate",
    "body": [
      "extern crate ${1:name};"
    ],
    "description": "extern crate …;"
  },
  "extern-fn": {
    "prefix": "_extern-fn",
    "body": [
      "extern \"C\" fn ${1:name}(${2:arg}: ${3:Type}) -> ${4:RetType} {",
      "    ${5:// add code here}",
      "}"
    ],
    "description": "extern \"C\" fn …(…) { … }"
  },
  "extern-mod": {
    "prefix": "_extern-mod",
    "body": [
      "extern \"C\" {",
      "    ${2:// add code here}",
      "}"
    ],
    "description": "extern \"C\" { … }"
  },
  "pfn": {
    "prefix": "_pfn",
    "body": [
      "pub fn ${1:name}(${2:arg}: ${3:Type}) -> ${4:RetType} {",
      "    ${5:todo!();}",
      "}"
    ],
    "description": "pub fn …(…) { … }"
  },
  "fn": {
    "prefix": "_fn",
    "body": [
      "fn ${1:name}(${2:arg}: ${3:Type}) -> ${4:RetType} {",
      "    ${5:todo!();}",
      "}"
    ],
    "description": "fn …(…) { … }"
  },
  "for": {
    "prefix": "_for",
    "body": [
      "for ${1:pat} in ${2:expr} {",
      "    ${3:todo!();}",
      "}"
    ],
    "description": "for … in … { … }"
  },
  "if-let": {
    "prefix": "_if-let",
    "body": [
      "if let ${1:Some(pat)} = ${2:expr} {",
      "    ${0:todo!();}",
      "}"
    ],
    "description": "if let … = … { … }"
  },
  "if": {
    "prefix": "_if",
    "body": [
      "if ${1:condition} {",
      "    ${2:todo!();}",
      "}"
    ],
    "description": "if … { … }"
  },
  "impl-trait": {
    "prefix": "_impl-trait",
    "body": [
      "impl ${1:Trait} for ${2:Type} {",
      "    ${3:// add code here}",
      "}"
    ],
    "description": "impl … for … { … }"
  },
  "inline-fn": {
    "prefix": "_inline-fn",
    "body": [
      "#[inline]",
      "pub fn ${1:name}() {",
      "    ${2:todo!();}",
      "}"
    ],
    "description": "inlined function"
  },
  "macro_rules": {
    "prefix": "_macro_rules",
    "body": [
      "macro_rules! ${1:name} {",
      "    (${2}) => (${3})",
      "}"
    ],
    "description": "macro_rules! … { … }"
  },
  "main": {
    "prefix": "_main",
    "body": [
      "fn main() {",
      "    ${1:todo!();}",
      "}"
    ],
    "description": "fn main() { … }"
  },
  "match": {
    "prefix": "_match",
    "body": [
      "match ${1:expr} {}"
    ],
    "description": "match … { … }"
  },
  "mod-block": {
    "prefix": "_mod-block",
    "body": [
      "mod ${1:name} {",
      "    ${2:// add code here}",
      "}"
    ],
    "description": "mod … { … }"
  },
  "static": {
    "prefix": "_static",
    "body": [
      "static ${1:STATIC}: ${2:Type} = ${4:init};"
    ],
    "description": "static …: … = …;"
  },
  "struct-tuple": {
    "prefix": "_struct-tuple",
    "body": [
      "struct ${1:Name}(${2:Type});"
    ],
    "description": "struct …(…);"
  },
  "struct-unit": {
    "prefix": "_struct-unit",
    "body": [
      "struct ${1:Name};"
    ],
    "description": "struct …;"
  },
  "struct": {
    "prefix": "_struct",
    "body": [
      "#[derive(Debug)]",
      "struct ${1:Name} {",
      "    ${2:field}: ${3:Type}",
      "}"
    ],
    "description": "struct … { … }"
  },
  "modtest": {
    "prefix": "_modtest",
    "body": [
      "#[cfg(test)]",
      "mod test {",
      "    #[test]",
      "    fn ${1:name}() {",
      "        ${2:todo!();}",
      "    }",
      "}"
    ],
    "description": "#[cfg(test)]\nmod test {...}"
  },
  "test": {
    "prefix": "_test",
    "body": [
      "#[test]",
      "fn ${1:name}() {",
      "    ${2:todo!();}",
      "}"
    ],
    "description": "#[test]"
  },
  "trait": {
    "prefix": "_trait",
    "body": [
      "trait ${1:Name} {",
      "    ${2:// add code here}",
      "}",
      ""
    ],
    "description": "trait … { … }"
  },
  "type": {
    "prefix": "_type",
    "body": [
      "type ${1:Alias} = ${2:Type};"
    ],
    "description": "type … = …;"
  },
  "while-let": {
    "prefix": "_while-let",
    "body": [
      "while let ${1:Some(pat)} = ${2:expr} {",
      "    ${0:todo!();}",
      "}"
    ],
    "description": "while let … = … { … }"
  },
  "while": {
    "prefix": "_while",
    "body": [
      "while ${1:condition} {",
      "    ${2:todo!();}",
      "}"
    ],
    "description": "while … { … }"
  },
  "pafn": {
    "prefix": "_pafn",
    "body": [
      "pub async fn ${1:name}(${2:arg}: ${3:Type}) -> ${4:RetType} {",
      "    ${5:todo!();}",
      "}"
    ],
    "description": "pub async fn …(…) { … }"
  },
  "afn": {
    "prefix": "_afn",
    "body": [
      "async fn ${1:name}(${2:arg}: ${3:Type}) -> ${4:RetType} {",
      "    ${5:todo!();}",
      "}"
    ],
    "description": "async fn …(…) { … }"
  }
}